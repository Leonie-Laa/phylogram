---
title: "The **phylogram** R package for evolutionary tree development"
author: "Shaun Wilkinson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: phylogram.bib
vignette: >
  %\VignetteIndexEntry{phylogram introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
#knitr::opts_chunk$set(out.width='750px', dpi=200)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

--------------------------------------------------------------------------------
## Abstract
**phylogram** is an R package for building and manipulating evolutionary trees 
as deeply-nested lists ("dendrogram" objects). 
It provides functions for importing and exporting trees in the Newick 
parenthetic text format, as well as several editing functions for command-line 
tree manipulation.
With an emphasis on speed and computational efficiency, **phylogram** also 
includes a suite of tools for rapidly generating very large trees and distance 
matrices using fast alignment-free k-mer counting and sequence embedding 
techniques.
This will make R's nested-list architecture more accessible to evolutionary 
biologists, and will be especially useful for the analysis of very large 
sequence datasets.


## Introduction
The R environment continues to gain popularity as a platform for
working with evolutionary trees. This is primarily due to the reproducible 
code-based workflow and the many powerful analytical tools freely 
available within a suite of open-source packages including **ape** 
[@paradis2004ape], **phangorn** [@schliep2011phangorn] 
and **Phytools** [@revell2012phytools]. 
These packages typically employ a tree representation known as the 
"phylo" object, a list whose primary element is an integer matrix 
with one row for each edge in the graph, 
and two columns giving the identities of the two nodes connected 
by the edge. 
Other list elements may include edge lengths (weights), labels, and 
the identity of the root node if applicable. 


An alternative structure for evolutionary trees in R is the 
"dendrogram" object, generated using the function 
`as.dendrogram` introduced in the **stats** package [@R2017].
Rather than a matrix of edges, a dendrogram is a heirarchical list 
(or a simple length-1 vector if the object is a single terminal leaf node). 
These 'lists of lists' can be deeply nested, with the limit depending on 
the C stack size (settable with `options("expressions")`).
A useful feature of this representation is its modularity, whereby the 
subtree of a tree is itself a tree - a dendrogram within a dendrogram. 
This means that dendrogram objects are subsettable in the same 
way that standard lists are, which in addition to the inbuilt
editing functions such as `cut` and `merge`, 
facilitates intuitive command-line tree manipulation. 
An especially powerful feature of this object type is that tree 
manipulation operations can be carried out recursively 
using fast inbuilt functions in the "apply" family such as `dendrapply` 
and `lapply`. 

Each node of a dendrogram object has the following mandatory attributes: 

* "height" the position of the node along the vertical axis 
   (assuming the graph is orientated vertically)
* "midpoint" the horizontal distance of the node from the left-most member 
   of the subtree (where the horizontal distance between adjacent leaves is 1 unit)
* "members" the number of terminal leaf nodes belonging to the node 
* "class" all nodes have the class attribute "dendrogram" 

Rather than lists, terminal leaf nodes are length-1 integer vectors whose
values correspond to the indices of the members in the set. 
The "members" attributes of leaf nodes is always set to 1, 
the "midpoint" attribute is 0, and they have two additional attributes:    

* "leaf" TRUE for terminal nodes (NULL otherwise)
* "label" an optional character string giving the name of the taxon or group

Aside from those listed above, users may attach other objects 
as attributes to the dendrogram nodes. For example, "label" attributes
can be attached to inner nodes, and users can specify plotting parameters
for each node by setting the attributes "nodePar" and "edgePar". 

#### Example 1: Build a dendrogram object manually
Consider the simple example of a tree with three members named 
"A", "B" and "C", where "B" and "C" are more closely related
to eachother than they are to "A". 
An unweighted Newick string for this tree would then be:  
$(A,(B,C));$  
We could manually create a dendrogram object for this basic phylogeny
and plot the tree as follows:

```{r}
x <- list(1, list(2, 3))
## attach "leaf" and "label" attributes to leaf nodes
attr(x[[1]], "leaf") <- TRUE
attr(x[[2]][[1]], "leaf") <- attr(x[[2]][[2]], "leaf") <- TRUE
attr(x[[1]], "label") <- "A"
attr(x[[2]][[1]], "label") <- "B"
attr(x[[2]][[2]], "label") <- "C"
## set "height" attributes for all nodes
attr(x, "height") <- 1
attr(x[[1]], "height") <- 0
attr(x[[2]], "height") <- 0.5
attr(x[[2]][[1]], "height") <- attr(x[[2]][[2]], "height") <- 0
## set "midpoints" attributes for all nodes
attr(x, "midpoint") <- 0.75
attr(x[[1]], "midpoint") <- 0
attr(x[[2]], "midpoint") <- 0.5
attr(x[[2]][[1]], "midpoint") <- attr(x[[2]][[2]], "midpoint") <- 0
## set "members" attributes for all nodes
attr(x, "members") <- 3
attr(x[[1]], "members") <- 1
attr(x[[2]], "members") <- 2
attr(x[[2]][[1]], "members") <- attr(x[[2]][[2]], "members") <- 1
## set class as "dendrogram" 
## Note that setting the class for the root node
## automatically sets the class of all nested subnodes
class(x) <- "dendrogram"

### plot the dendrogram
plot(x, yaxt = "n")
```
  
**Figure 1:** A simple dendrogram with three terminal leaf nodes

As demonstrated in this example, manually setting attributes on dendrogram
objects can be rather tedious, motivating the development of functions 
automating the generation and manipulation of tree 
structures of this type.


## The 'phylogram' package
Here, we introduce **phylogram**, an R package for working with 
evolutionary trees as dendrogram objects in the heirarchical 
(nested) list format. 
The package contains functions for importing and exporting trees to 
and from Newick-style parenthetic text, 
computing distance matrices, and assembling, visualizing, 
manipulating and exporting phylogenetic trees for publication.
These functions are detailed below with examples of their utility.


### Importing and exporting trees
The Newick (a.k.a. New Hampshire) parenthetic text 
format [@felsensteinnewick] is a universal phylogenetic tree 
representation that is compatible with most tree-editing software. 
This includes other R packages such as **ape**, which 
offers the `read.tree` function for parsing Newick
strings into "phylo" objects.
The **phylogram** package features the text parser `read.dendrogram`
which reads character strings and text files in the Newick
format and generates "dendrogram" class objects.
This function supports weighted edges, labels with special metacharacters 
(provided they are enclosed in single quotation marks), comments 
(enclosed in square brackets; ignored by the parser), 
multifuricating nodes, and both rooted and unrooted trees.
The current version of this package ignores inner-node labels 
(the addition of "label" attributes for non-leaf 
dendrogram nodes will be available in a future release). 
Objects of class "dendrogram" can also be exported as 
Newick-style parenthetic text using the function 
`write.dendrogram`.

#### Example 2: Import and export a tree from a Newick string
The simple Newick string in Example 1 can be imported as a 
dendrogram object using the `read.dendrogram` function 
as follows:

```{r}
newick <- "(A,(B,C));"
x <- phylogram::read.dendrogram(text = newick)
```

The following command writes the object back to the console in 
Newick format without edge weights:

```{r}
phylogram::write.dendrogram(x, edges = FALSE)
```

The syntax is similar when reading and writing text files, 
except that the `text` argument is replaced by `file`, 
and a valid file path is passed to the function. 


### Computing distance matrices
A primary focus of the **phylogram** package is to facilitate the assembly 
of very large trees as quickly and efficiently as possible. 
Hence the default distance metric used by this package is the fast 
alignment-free k-mer (k-tuple) distance measure outlined by Edgar 
[-@edgar2004local].
For two DNA sequences $a$ and $b$ the fractional common k-mer count over the 
$4^k$ possible words of length $k$ is calculated as:

$$
\begin{equation}
F  = \sum\limits_{\tau}
\frac{min (n_a(\tau), n_b (\tau))}{min (L_a , L_b ) - k + 1} \tag{1}
\end{equation}
$$
where $\tau$ is a k-mer, $n_a(\tau)$ and $n_b(\tau)$ are the number of times 
$\tau$ appears in each sequence, $k$ is the tuple length and $L$ refers to 
the sequence length.

We then calculate the pairwise distance between $a$ and $b$ as: 

$$
\begin{equation}
d = \frac{log(0.1 + F) - log(1.1)}{log(0.1)} \tag{2}
\end{equation}
$$

The alternative option detailed in Yang & Zhang [-@yang2008performance] can also be 
invoked by setting `measure = YANG08`:

$$
\begin{equation}
d  = \sum\limits_{\tau}|\frac{n_a(\tau)}{L_a - k + 1} - \frac{n_b(\tau)}{L_b - k + 1}|^2 \tag{3}
\end{equation}
$$
The `kdistance` function computes a standard $n \times n$ distance matrix 
(where $n$ is the number of sequences), returning an object of class "dist".
DNA and amino acid sequences can be passed to `kdistance` either as unaligned 
lists or aligned matrices, preferably in either 
the "DNAbin" or "AAbin" raw-byte format (see the **ape** package documentation 
for more information on these S3 classes). 
Character vectors are supported; however ambiguity 
codes may not be recognized or treated approprately 
(ambiguity codes are counted according to their underlying residue frequencies - 
e.g. the 5-mer "ACRGT" would contribute 0.5 to the tally for "ACAGT" and 0.5 to that of "ACGGT"). 
To minimize computation time when counting longer k-mers (k > 2), 
amino acid sequences in the raw "AAbin" format are automatically compressed using 
the Dayhoff-6 alphabet as detailed in Edgar [-@edgar2004local]. 
Note that amino acid sequences will not be compressed if 
they are supplied as a list of character vectors rather than an "AAbin" object, 
in which case the k-mer length should be reduced 
(k < 4) to avoid excessive memory use and computation time. 

#### Example 3: Compute a k-mer distance matrix for the woodmouse dataset
The **ape** package contains a dataset of 15 aligned mitochondrial 
cytochrome *b* gene DNA seqences from the woodmouse *Apodemus sylvaticus*. 
This is a subset of those originally published in 
Michaux et al. [-@michaux2003mitochondrial].
While the **phylogram** distance functions do not require sequences to 
be aligned, this example will enable us to compare our k-mer distances
with the traditional alignment-reliant distances produced by 
`ape::dist.dna`. First, load the woodmouse dataset and view the first few 
rows and columns as follows:

```{r}
library(ape)
data(woodmouse)
ape::as.character.DNAbin(woodmouse[1:5, 1:5])
```


This is a semi-global ('glocal') alignment featuring some 
incomplete sequences, with unknown characters represented by 
the ambiguity code "n" (e.g. No305). To 
avoid artificially inflating the distances between these partial sequences
and the others, we first trim the gappy ends by subsetting 
the 'true' global alignment (the **ape** function `dist.dna` 
also removes columns with ambiguity codes prior to distance computation 
by default ).

```{r}
woodmouse <- woodmouse[, 47:962] 
```

To compute the full $n \times n$ distance matrix using a k-mer size of 5, run:

```{r}
woodmouse.kdist <- phylogram::kdistance(woodmouse, k = 5)

### show the first 5 rows and columns of the full distance matrix
print(as.matrix(woodmouse.kdist)[1:5, 1:5], digits = 2)

```


### Sequence embedding
For a set of $n$ sequences, the `kdistance` operation has time and 
memory complexity $O(n^2)$, and can 
quickly become computationally infeasible for more than ~ 10,000 sequences.
As such, the **phylogram** package also offers the function `mbed` for 
fast asymmetrical distance matrix computation [@blackshields2010sequence].
Rather than computing a full symmetrical $n \times n$ distance matrix as 
illustrated above, the `mbed` function computes the distances 
from each sequence to a smaller (or equal) sized subset of 'seed' sequences. 

Blackshields et al. [-@blackshields2010sequence] suggest that a 
suitable number of seed 
sequences is $log_2(n)^2$ (where $n$ is the total number of 
sequences). This is clearly much more 
efficient than computing a standard $n \times n$ distance matrix 
when the number of sequences is large.
For example, for a set of $100,000$ sequences, the embedding routine 
would compute $100,000 \times log_2(100,000)^2 = 27,600,000$ 
distance calculations as opposed to $100,000^2 = 10,000,000,000$
for a standard (square) distance matrix.

For maximum information retention following the embedding process
it is generally desirable to select the seed sequences based on their 
uniqueness, rather than simply selecting a random subset 
[@blackshields2010sequence]. 
Hence if 'seeds' is set to NULL (the default setting) the the `mbed` 
function selects the subset by clustering the sequence set into 
$t$ groups using the k-means algorithm (*k* = *t*), 
and choosing one representative from each group. 
Users can alternatively pass an integer vector (as in the above example)
to specify the seeds manually. 
See Blackshields et al. [-@blackshields2010sequence] for other 
suggested options for seed selection. 


#### Example 4: Compute an embedded k-mer distance matrix
The following code computes the k-mer distances (for *k* = 5) from each 
of the sequences in the woodmouse dataset to five randomly selected 
seed sequences:


```{r}
set.seed(999)
seeds <- sample(1:15, size = 5)
woodmouse.mbed <- phylogram::mbed(woodmouse, seeds = seeds, k = 5)
### This object has additional attributes that may 
### include a large matrix of k-mer counts if counts = TRUE.
### Hence there is a summary print method 
### to avoid flooding the console. 
### To show the matrix of embedded sequences only, 
### remove the attributes by subsetting the distance matrix
print(woodmouse.mbed[,], digits = 2)
```


### Building trees
One notable drawback of the sequence embedding method is that 
traditional agglomerative (bottom-up) tree-building methods such as 
neighbor-joining and UPGMA depend on a full $n \times n$ distance matrix. 
To circumvent this the **phylogram** package features 
a function called `topdown` for divisive tree building, by recursively 
partitioning the embedded sequences using k-means clustering (*k* = 2). 
While recursive partitioning of embedded 
sequences may not necessarily 
reconstruct sufficiently accurate phylogenetic trees for taxonomic 
purposes, it offers a fast and efficient means of producing large trees 
for a variety of other applications. 
These include tree-based sequence weighting (e.g. Gerstein et al. 1994), 
guide trees for progressive multiple sequence alignment (e.g. Sievers 
et al. 2011), and other recursive operations such as
classification tree learning.

#### Example 5: reconstruct a phylogenetic tree for the woodmice data 
In this example we will compare the fast embedded k-mer distance/ 
top-down tree method with standard neighbor-joining 
trees constructed from full distance matrices computed using both the 
alignment-free k-mer distance and the Kimura [-@kimura1980simple] 
distance measure as used in the examples in the **ape** package.


```{r, out.width='700px', out.height='550px', dpi=500}
### set out plotting panes
op <- par(no.readonly = TRUE)
par(mfrow = c(1, 3), mar = c(1, 2, 3, 3), cex = 0.3)

### (1) Neighbor joining tree for Kimura 1980 distance matrix
### compute the n x n K80 distance matrix 
woodmouse.dist <- ape::dist.dna(woodmouse, model = "K80") 
### build the neighbor-joining tree
tree1 <- ape::nj(woodmouse.dist)
### sort nodes by size
tree1 <- ape::ladderize(tree1)
### plot the nj tree
plot(tree1, font = 1, cex = 1, 
     main = "Neighbor-joining tree with\nK80 distance")

### (2) Neighbor joining tree for full k-mer distance matrix
tree2 <- ape::nj(woodmouse.kdist)
### sort nodes by size
tree2 <- ape::ladderize(tree2)
### plot the nj tree
plot(tree2, font = 1, cex = 1, 
     main = "Neighbor-joining tree with\nstandard k-mer distance (k=5)")

### (3) topdown tree for embedded k-mer distances
set.seed(999)
tree3 <- phylogram::topdown(woodmouse, seeds = seeds, weighted = TRUE)
### sort nodes by size
tree3 <- phylogram::ladder(tree3)
tree3 <- phylogram::reposition(tree3, shift = 0.02)
np <- list(pch = c(NA, NA), lab.cex = 1)
plot(tree3, horiz = TRUE, yaxt = "n", nodePar = np,
     main = "Top-down tree with\nembedded k-mer distance (k=5)")

### reset plotting parameters
par(op)
```

**Figure 2:** Comparison of tree-building methods for the woodmouse sequences 

In this example, the two neighbor-joining trees are relatively congruent 
regardless of the distance measure used. The divisive (topdown) tree retained 
the fine-scale relationships but gave differing results for the basal nodes, 
suggesting that the number of seeds may have been too low and/or not selected 
for maximum information retention (recall that these were chosen randomly). 

### Tree editing/manipulation
While dendrogram objects can be edited fairly easily using standard 
list- and vector subsetting operators, the **phylogram** package features 
several additional functions to facilite some of the more common 
manipulation operations.
Leaf nodes and internal branching nodes can be removed 
using the function `prune`, which identifies and 
recursively deletes nodes based on regular expression pattern 
matching of node "label" attributes.
To aid vizualization, the function `ladder` rearranges
the tree, sorting nodes by the number of members (analogous to the
`ladderize ` function in the **ape** package). Another function 
aiding in tree visualization is `ultrametricize `, which
resets the "height" attributes of all terminal leaf nodes to zero. 
The function `reposition` scales the height of all nodes in
a tree by a given constant (passed *via* the argument `shift`), 
and features the option to reset all node heights so that height of 
the farthest terminal leaf node from the root is zero (by specifying 
`shift = "reset"`). 
The function `remidpoint` recursively corrects all "midpoint", 
"members" and "leaf" attributes following manual editing of a tree.


### Tree vizualization 
Publication-quality trees can be generated from dendrogram objects 
using the **stats** plotting function `plot.dendrogram`, and the extensive
plotting functions available in a dendrogram-enhancing packages such as 
**circlize** [@Gu2014] and **dendextend** [@Galili2015].
The latter also offers the facility to convert dendrograms to "ggdend" objects, 
for which many powerful 'grammar of graphics' plotting functions are available in 
the **ggplot2** [@Wickam2009] and **ggdendro** [@deVries2016] packages. 
Moreover, there are several advanced plotting options for "phylo" objects in 
the **ape** package [@paradis2004ape], made accessible for dendrogram objects 
here *via* the Newick import/export functions `read.dendrogram` and `write.dendrogram`. 
With the extensive tree visualization options already available, 
we elected not to include any additional plotting 
functions in the **phylogram** package. 


## Future direction
A primary motivation for the development of this package was the requirement
to perform recursive tree operations in a straightforward and intuitive manner.
Machine learning and data mining techniques such as classification and 
regression trees (CART) offer many potential benefits for the field 
of bioinformatics, particularly in the exploratory 
analysis of large datasets generated by high-throughput sequencing. 
This tool makes the nested-list architecture, which is ideally suited to such 
tasks, more accessible. We hope that it will help evolutionary biologists to further explore this appealing opportunity.  


## References 
